<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ZIKA CIV LEAGUE</title>

  <style>
    @font-face{
      font-family: "ZikaTitle";
      src: url("assets/fonts/OPTIColumna-Solid.otf") format("opentype");
      font-display: swap;
    }

    :root{
      --titleGold: #d5ac56;

      /* --- overall scaling (keeps parity across 16:9 resolutions) --- */
      /* vmin ties sizing to the smaller of width/height, which helps keep
         ‚Äúpositional parity‚Äù across 1080p / 1440p / 4K 16:9. */
      --u: min(1.0vmin, 1.0vh);

      /* --- leaderboard sizes --- */
      --trophyIcon: clamp(14px, 1.6vmin, 20px);
      --trophyNum: clamp(14px, 1.7vmin, 20px);

      --p1: clamp(108px, 16vmin, 210px);
      --p2: clamp(92px, 13vmin, 170px);
      --p3: clamp(92px, 13vmin, 170px);
      --p4: clamp(78px, 11vmin, 145px);
      --p5: clamp(78px, 11vmin, 145px);

      /* recent wins icon scales with player avatar */
      --r1: calc(var(--p1) * 0.22);
      --r2: calc(var(--p2) * 0.22);
      --r3: calc(var(--p3) * 0.22);
      --r4: calc(var(--p4) * 0.22);
      --r5: calc(var(--p5) * 0.22);

      /* --- parchment / timeline sizing --- */
      --nodeW: clamp(520px, 46vw, 760px);
      --nodeGap: clamp(90px, 8vw, 140px);
      --timelinePad: clamp(110px, 10vw, 180px);

      /* ‚Äúcentre line‚Äù of the tech-tree/timeline (table centres sit on this) */
      --tableLineY: 26vh;

      /* Under-table podium block position */
      --podiumTop: calc(var(--tableLineY) + 18vh);

      /* Under-table avatar sizes (bigger, but guaranteed to fit) */
      --m1: clamp(96px, 12.5vmin, 170px);
      --m2: clamp(78px, 10.3vmin, 135px);
      --m3: clamp(70px, 9.3vmin, 122px);

      --mGapRow: clamp(18px, 2.3vmin, 28px);
      --mGapPair: clamp(22px, 2.5vmin, 34px); /* gap between player and civ */
    }

    *{ box-sizing:border-box; }
    html, body{
      height:100%;
      margin:0;
      overflow:hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:#05060a;
    }

    /* ===== horizontal scroller ===== */
    #scroller{
      height:100vh;
      overflow-x:auto;
      overflow-y:hidden;
      scroll-behavior:auto; /* we do our own smooth inertial */
      -webkit-overflow-scrolling:touch;
      outline:none;
      background:#05060a;
    }
    #row{
      display:flex;
      height:100%;
      width:max-content;
    }

    /* ===== podium page ===== */
    .podiumPanel{
      position:relative;
      width:100vw;
      height:100vh;
      flex:0 0 100vw;
      overflow:hidden;
    }

    .bgMap{
      position:absolute;
      inset:0;
      z-index:0;
      background:
        radial-gradient(1200px 800px at 25% 20%, rgba(130,170,255,0.20), transparent 60%),
        radial-gradient(900px 600px at 70% 60%, rgba(255,255,255,0.08), transparent 65%),
        url("assets/backgrounds/map.png");
      background-size:cover;
      background-position:center;
      filter:saturate(1.03) contrast(1.05);
      transform: translate3d(0,0,0);
    }
    .mapTint{
      position:absolute;
      inset:0;
      z-index:1;
      background: rgba(5,10,18,0.22);
    }

    /* statues */
    .statue{
      position:absolute;
      bottom:-10vh; /* let legs fall off-screen */
      width: min(46vw, 900px);
      max-width: 900px;
      z-index:2;
      opacity:0.95;
      filter: drop-shadow(0 24px 60px rgba(0,0,0,0.55));
      pointer-events:none;
      transform: translate3d(0,0,0);
    }
    .statue.left{
      left:-4vw;
    }
    .statue.right{
      right:-4vw;
      /* IMPORTANT: do NOT flip gilgamesh */
      transform: translate3d(0,0,0);
    }

    .podiumContent{
      position:relative;
      z-index:4;
      height:100%;
      width:100%;
    }

    .leagueTitle{
      position:absolute;
      top: 4.2vh;
      left: 50%;
      transform: translateX(-50%);
      margin:0;
      font-family: "ZikaTitle", system-ui, sans-serif;
      font-size: clamp(42px, 5.2vmin, 78px);
      letter-spacing: 1.2px;
      color: var(--titleGold);
      text-shadow: 0 20px 70px rgba(0,0,0,0.45);
      text-align:center;
      z-index:5;
      white-space:nowrap;
    }

    /* bottom stats (single row along bottom) */
    .victoryRow{
      position:absolute;
      bottom: 5.2vh;
      left: 50%;
      transform: translateX(-50%);
      display:flex;
      gap: clamp(16px, 2.4vmin, 28px);
      align-items:center;
      justify-content:center;
      font-size: clamp(12px, 1.6vmin, 14px);
      color: rgba(255,255,255,0.85);
      text-shadow: 0 16px 40px rgba(0,0,0,0.40);
      z-index:6;
      white-space:nowrap;
    }
    .victoryRow strong{ color: rgba(255,255,255,0.95); }

    .penaltyNote{
      position:absolute;
      left: 18px;
      bottom: 18px;
      z-index:7;
      font-size: 12px;
      color: rgba(255,255,255,0.70);
      background: rgba(0,0,0,0.22);
      border: 1px solid rgba(255,255,255,0.10);
      padding: 10px 12px;
      border-radius: 12px;
      backdrop-filter: blur(8px);
      user-select:none;
    }
    .scrollHint{
      position:absolute;
      right: 18px;
      bottom: 18px;
      z-index:7;
      font-size: 12px;
      color: rgba(255,255,255,0.78);
      background: rgba(0,0,0,0.30);
      border: 1px solid rgba(255,255,255,0.12);
      padding: 10px 12px;
      border-radius: 12px;
      backdrop-filter: blur(8px);
      user-select:none;
    }

    /* Leaderboard layout: absolute anchors so boxes don‚Äôt push each other */
    .slot{
      position:absolute;
      transform: translate(-50%, -50%);
      display:flex;
      align-items:center;
      gap: clamp(14px, 1.8vmin, 20px);
      z-index:6;
    }

    /* trophy column (left) */
    .trophies{
      display:flex;
      flex-direction:column;
      gap: clamp(8px, 1.0vmin, 12px);
      align-items:flex-end;
      justify-content:center;
      height: 100%;
      min-width: clamp(44px, 5vmin, 64px);
      color: rgba(255,255,255,0.92);
      text-shadow: 0 12px 22px rgba(0,0,0,0.35);
      user-select:none;
    }
    .tLine{
      display:flex;
      align-items:center;
      gap: 8px;
      font-weight: 900;
      font-size: var(--trophyNum);
      line-height:1;
    }
    .tLine .num{ min-width: 18px; text-align:right; }
    .tLine .ico{ font-size: var(--trophyIcon); width: 18px; text-align:center; }

    /* avatar itself (NO border, no background box) */
    .pAvatar{
      display:block;
      object-fit:contain; /* do NOT crop (your custom PNG shapes stay intact) */
      width: 120px;
      height: 120px;
      filter: drop-shadow(0 18px 38px rgba(0,0,0,0.40));
    }

    /* stats on right of avatar (stacked) */
    .pStats{
      display:flex;
      flex-direction:column;
      gap: 6px;
      justify-content:center;
      color: rgba(255,255,255,0.92);
      text-shadow: 0 16px 40px rgba(0,0,0,0.40);
      font-size: clamp(12px, 1.45vmin, 14px);
      line-height: 1.15;
      min-width: clamp(86px, 9vmin, 110px);
      user-select:none;
    }
    .pStats .k{ opacity:0.9; }

    /* recent wins box UNDER the avatar (always fits 5) */
    .recentBox{
      position:absolute;
      left: 50%;
      transform: translateX(-50%);
      top: calc(50% + 0px); /* will be set per-slot with JS to sit under avatar */
      width: 100%;
      display:flex;
      justify-content:center;
      z-index:6;
      pointer-events:none;
    }
    .recentInner{
      background: rgba(0,0,0,0.22);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 14px;
      backdrop-filter: blur(10px);
      padding: 10px 12px;
      display:grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 10px;
      align-items:center;
      justify-items:center;
      width: clamp(240px, 24vmin, 320px); /* guaranteed room for 5 */
      min-height: 48px;
    }
    .recentInner img{
      display:block;
      object-fit:contain;  /* don‚Äôt crop leader portraits */
      filter: drop-shadow(0 10px 20px rgba(0,0,0,0.25));
    }

    /* ===== timeline page ===== */
    .timelinePanel{
      position:relative;
      height:100vh;
      flex: 0 0 auto;
      overflow:hidden;
    }

    .bgParchment{
      position:absolute;
      inset:0;
      z-index:0;
      background-image: url("assets/backgrounds/parchment.png");
      background-repeat: repeat-x;
      background-size: auto 100vh;
      background-position: left top;
      transform: translate3d(0,0,0);
    }
    .bgLines{
      position:absolute;
      inset:0;
      z-index:1;
      opacity:0.10;
      mix-blend-mode:multiply;
      background:
        repeating-linear-gradient(0deg, rgba(60,40,20,0.18) 0px, rgba(60,40,20,0.18) 1px, transparent 1px, transparent 44px),
        repeating-linear-gradient(90deg, rgba(60,40,20,0.10) 0px, rgba(60,40,20,0.10) 1px, transparent 1px, transparent 60px);
      transform: translate3d(0,0,0);
    }
    .timelineLine{
      position:absolute;
      left: var(--timelinePad);
      right: var(--timelinePad);
      top: var(--tableLineY);
      height: 2px;
      border-top: 2px dotted rgba(70,45,20,0.45);
      z-index:2; /* behind tables */
      pointer-events:none;
      transform: translateY(-50%);
    }

    .timelineContent{
      position:relative;
      z-index:5;
      height:100%;
      padding: 18px var(--timelinePad);
      display:flex;
      align-items:stretch;
    }

    .nodesRow{
      position:relative;
      display:flex;
      align-items:stretch;
      gap: var(--nodeGap);
      height:100%;
      padding-right: var(--timelinePad);
    }

    .matchNode{
      width: var(--nodeW);
      height: 100%;
      position:relative;
      display:flex;
      align-items:stretch;
      justify-content:center;
    }

    .matchTableWrap{
      position:absolute;
      top: var(--tableLineY);
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100%;
      border-radius: 18px;
      background: rgba(255,255,255,0.34);
      border: 1px solid rgba(160,120,60,0.24);
      box-shadow: 0 22px 65px rgba(0,0,0,0.30);
      backdrop-filter: blur(10px);
      overflow: visible; /* IMPORTANT: allow pills to overhang */
      color: rgba(35,22,10,0.92);
      z-index:6;
    }

    .tableTop{
      position:relative;
      padding-top: 18px; /* space for the overhang pills visually */
      border-radius: 18px;
      overflow:hidden; /* only for the table body; pills are outside */
    }

    .pill{
      position:absolute;
      top: -14px;
      padding: 8px 12px;
      border-radius: 999px;
      font-weight: 900;
      font-size: 12px;
      letter-spacing: 0.2px;
      background: rgba(255,255,255,0.62);
      border: 1px solid rgba(160,120,60,0.28);
      box-shadow: 0 14px 30px rgba(0,0,0,0.15);
      color: rgba(45,28,12,0.92);
      white-space:nowrap;
      z-index:10;
    }
    .pill.left{ left: 14px; }
    .pill.right{ right: 14px; }

    .matchTitle{
      padding: 12px 14px 10px;
      background: rgba(214,180,90,0.14);
      border-bottom: 1px solid rgba(160,120,60,0.18);
      font-family: "ZikaTitle", system-ui, sans-serif;
      letter-spacing: 0.7px;
      font-size: 16px;
      color: rgba(45,28,12,0.92);
      text-align:center;
      text-transform: uppercase;
    }

    table{
      width:100%;
      border-collapse: collapse;
      font-size: 14px;
      table-layout: fixed;
      background: rgba(255,255,255,0.08);
    }
    thead th{
      text-align:left;
      padding: 10px 12px;
      font-size: 11px;
      letter-spacing: 0.3px;
      text-transform: uppercase;
      opacity:0.88;
      border-bottom: 1px solid rgba(160,120,60,0.14);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    tbody td{
      padding: 10px 12px;
      border-bottom: 1px solid rgba(160,120,60,0.10);
      vertical-align:middle;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    tbody tr:last-child td{ border-bottom:none; }

    /* widen civ column so names never spill */
    .thPoints{ width: 80px; }
    .thPlayer{ width: 110px; }
    .thScore{  width: 78px; }
    .thLeader{ width: 170px; }
    .thCiv{    width: 160px; }

    /* Under-table podium: align columns perfectly (trophy | player | civ) */
    .nodePodium{
      position:absolute;
      top: var(--podiumTop);
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap: var(--mGapRow);
      z-index:6;
      pointer-events:none;
    }

    .placeRow{
      display:grid;
      grid-template-columns: 44px auto auto;
      align-items:center;
      column-gap: var(--mGapPair);
      justify-items:center;
    }

    .placeIco{
      width: 44px;
      display:flex;
      justify-content:center;
      font-size: 28px;
      filter: drop-shadow(0 10px 18px rgba(0,0,0,0.18));
    }

    .mPlayer, .mCiv{
      display:block;
      object-fit:contain;
      filter: drop-shadow(0 18px 34px rgba(0,0,0,0.16));
    }

    .m1 .mPlayer{ width: var(--m1); height: var(--m1); }
    .m1 .mCiv{    width: var(--m1); height: var(--m1); }

    .m2 .mPlayer{ width: var(--m2); height: var(--m2); }
    .m2 .mCiv{    width: var(--m2); height: var(--m2); }

    .m3 .mPlayer{ width: var(--m3); height: var(--m3); }
    .m3 .mCiv{    width: var(--m3); height: var(--m3); }

    /* tiny safety if someone opens on a short-height display */
    @media (max-height: 820px){
      :root{
        --tableLineY: 24vh;
        --podiumTop: calc(var(--tableLineY) + 16vh);
        --m1: clamp(86px, 11.5vmin, 150px);
        --m2: clamp(72px, 9.8vmin, 125px);
        --m3: clamp(64px, 8.9vmin, 112px);
      }
    }
  </style>
</head>

<body>
  <div id="scroller" tabindex="0" aria-label="Zika Civ League horizontal scroller">
    <div id="row"></div>
  </div>

  <script>
    // ===== League standings rating settings =====
    const MISSED_GAME_PENALTY_AMOUNT = 0.25;

    const $ = (q, el=document) => el.querySelector(q);
    const $$ = (q, el=document) => [...el.querySelectorAll(q)];
    const safeText = (s) => (s ?? "").toString();

    function parseUKDateKey(dateUK){
      const [dd, mm, yyyy] = safeText(dateUK).split("/");
      return `${yyyy}${mm}${dd}`;
    }
    function byId(list){
      const m = new Map();
      for(const x of list) m.set(x.id, x);
      return m;
    }

    // URL-safe path builder for leader avatars (handles spaces + accents)
    function leaderAvatarPath(leaderName){
      if(!leaderName) return "";
      const file = encodeURIComponent(leaderName) + ".png";
      return "assets/civ_leader_avatars/" + file;
    }

    function avatarVariant(player, medal){ // "gold"|"silver"|"bronze"|null
      if(!player?.avatarPath) return "";
      if(!medal) return player.avatarPath;

      const base = player.avatarPath.replace(/\\/g, "/");
      const lastSlash = base.lastIndexOf("/");
      const dir = lastSlash >= 0 ? base.slice(0, lastSlash + 1) : "";
      return `${dir}${player.id}_${medal}.png`;
    }

    // Winner forced to place 1; others by score desc
    function computePlacements(match){
      const entries = [...match.entries];
      const winnerId = match.winnerPlayerId;
      const winnerEntry = entries.find(e => e.playerId === winnerId);
      const others = entries.filter(e => e.playerId !== winnerId);

      others.sort((a,b) => (b.score ?? 0) - (a.score ?? 0));

      const ordered = [];
      if(winnerEntry) ordered.push({ ...winnerEntry, place: 1 });
      for(let i=0;i<others.length;i++){
        ordered.push({ ...others[i], place: i+2 });
      }

      const n = ordered.length;
      for(const o of ordered){
        o.points = (n - o.place + 1);
      }
      return ordered;
    }

    function victoryTypeBreakdown(matches){
      const counts = new Map();
      for(const m of matches){
        const vt = safeText(m.victoryType);
        counts.set(vt, (counts.get(vt) ?? 0) + 1);
      }
      const total = matches.length || 1;
      const rows = [...counts.entries()].map(([k,v]) => ({ victoryType:k, count:v, pct:v/total }));
      rows.sort((a,b) => b.count - a.count);
      return rows;
    }
    function pct(x){ return `${Math.round(x*100)}%`; }

    function buildTotals(players, matches){
      const totals = new Map();
      for(const p of players){
        totals.set(p.id, {
          playerId: p.id,
          displayName: p.displayName,
          avatarPath: p.avatarPath,
          games: 0,
          totalPoints: 0,
          wins: 0,
          medals: { gold:0, silver:0, bronze:0 },
          avgPoints: 0,
          rating: 0
        });
      }

      for(const match of matches){
        const ordered = computePlacements(match);
        for(const o of ordered){
          const t = totals.get(o.playerId);
          if(!t) continue;
          t.games += 1;
          t.totalPoints += (o.points ?? 0);
          if(o.place === 1) t.wins += 1;
          if(o.place === 1) t.medals.gold += 1;
          if(o.place === 2) t.medals.silver += 1;
          if(o.place === 3) t.medals.bronze += 1;
        }
      }

      const totalGames = matches.length || 0;
      const rows = [...totals.values()].map(t => {
        const avgPoints = t.games ? (t.totalPoints / t.games) : 0;
        const playedFrac = totalGames ? (t.games / totalGames) : 0;
        const missedFrac = 1 - playedFrac;
        const penalty = missedFrac * MISSED_GAME_PENALTY_AMOUNT;
        const multiplier = 1 - penalty;
        const rating = avgPoints * multiplier;
        return { ...t, avgPoints, rating };
      });

      rows.sort((a,b) => b.rating - a.rating);
      return rows;
    }

    // Build recent winner leader avatars per player (newest -> oldest)
    function buildRecentWinsByPlayer(matchesNewestFirst){
      const map = new Map(); // playerId -> [{leaderName, path}]
      for(const m of matchesNewestFirst){
        const winnerId = m.winnerPlayerId;
        const winnerEntry = (m.entries || []).find(e => e.playerId === winnerId);
        if(!winnerId || !winnerEntry) continue;

        const leaderName = safeText(winnerEntry.leaderName || "");
        if(!leaderName) continue;

        const arr = map.get(winnerId) || [];
        // avoid immediate duplicates (optional)
        if(!arr.length || arr[arr.length-1].leaderName !== leaderName){
          arr.push({ leaderName, path: leaderAvatarPath(leaderName) });
        } else {
          arr.push({ leaderName, path: leaderAvatarPath(leaderName) });
        }
        map.set(winnerId, arr);
      }
      return map;
    }

    function renderPodium(totals, matchesNewestFirst, playersMap){
      const panel = document.createElement("section");
      panel.className = "podiumPanel";

      const bg = document.createElement("div");
      bg.className = "bgMap";
      bg.dataset.parallax = "0.12";
      panel.appendChild(bg);

      panel.appendChild(Object.assign(document.createElement("div"), { className: "mapTint" }));

      // statues
      const qin = document.createElement("img");
      qin.className = "statue left";
      qin.src = "assets/artwork/qin_shi_huang_statue.png";
      qin.alt = "Qin Shi Huang statue";
      qin.dataset.parallax = "0.18";
      panel.appendChild(qin);

      const gil = document.createElement("img");
      gil.className = "statue right";
      gil.src = "assets/artwork/gilgamesh_statue.png";
      gil.alt = "Gilgamesh statue";
      gil.dataset.parallax = "0.18";
      panel.appendChild(gil);

      const content = document.createElement("div");
      content.className = "podiumContent";
      panel.appendChild(content);

      const title = document.createElement("h1");
      title.className = "leagueTitle";
      title.textContent = "ZIKA CIV LEAGUE";
      content.appendChild(title);

      // bottom victory row
      const breakdown = victoryTypeBreakdown(matchesNewestFirst);
      const most = breakdown[0];
      const vRow = document.createElement("div");
      vRow.className = "victoryRow";
      vRow.innerHTML = `
        <span><strong>Most common victory:</strong> ${most ? `${most.victoryType} Victory (${Math.round(most.pct*100)}%)` : "‚Äî"}</span>
        ${breakdown.slice(0,6).map(r => `<span><strong>${r.victoryType} Victory:</strong> ${r.count} (${Math.round(r.pct*100)}%)</span>`).join("")}
      `;
      content.appendChild(vRow);

      // notes
      const note = document.createElement("div");
      note.className = "penaltyNote";
      note.textContent = "miss 50% of games, you get a 12.5% average score penalty";
      panel.appendChild(note);

      const hint = document.createElement("div");
      hint.className = "scrollHint";
      hint.textContent = "Scroll ‚Üí to view match timeline";
      panel.appendChild(hint);

      // positions (anchored to centre, not affected by box widths)
      // (x%, y%) in viewport terms
      const layout = [
        { rank:1, x:50, y:28 },
        { rank:2, x:30, y:53 },
        { rank:3, x:70, y:53 },
        { rank:4, x:30, y:78 },
        { rank:5, x:70, y:78 },
      ];

      const recentWins = buildRecentWinsByPlayer(matchesNewestFirst);

      function standingMedal(rank){
        if(rank === 1) return "gold";
        if(rank === 2) return "silver";
        if(rank === 3) return "bronze";
        return null;
      }
      function avatarSizeFor(rank){
        if(rank===1) return getComputedStyle(document.documentElement).getPropertyValue("--p1").trim();
        if(rank===2) return getComputedStyle(document.documentElement).getPropertyValue("--p2").trim();
        if(rank===3) return getComputedStyle(document.documentElement).getPropertyValue("--p3").trim();
        if(rank===4) return getComputedStyle(document.documentElement).getPropertyValue("--p4").trim();
        return getComputedStyle(document.documentElement).getPropertyValue("--p5").trim();
      }
      function recentIconSizeFor(rank){
        if(rank===1) return "var(--r1)";
        if(rank===2) return "var(--r2)";
        if(rank===3) return "var(--r3)";
        if(rank===4) return "var(--r4)";
        return "var(--r5)";
      }

      for(const pos of layout){
        const t = totals[pos.rank-1];
        if(!t) continue;

        const player = playersMap.get(t.playerId);
        const medal = standingMedal(pos.rank);

        const slot = document.createElement("div");
        slot.className = "slot";
        slot.style.left = pos.x + "vw";
        slot.style.top  = pos.y + "vh";

        // trophy column
        const trophies = document.createElement("div");
        trophies.className = "trophies";
        trophies.innerHTML = `
          <div class="tLine"><span class="num">${t.medals.gold}</span><span class="ico">üèÜ</span></div>
          <div class="tLine"><span class="num">${t.medals.silver}</span><span class="ico">ü•à</span></div>
          <div class="tLine"><span class="num">${t.medals.bronze}</span><span class="ico">ü•â</span></div>
        `;

        // avatar
        const img = document.createElement("img");
        img.className = "pAvatar";
        img.src = avatarVariant(player, medal);
        img.alt = `${t.displayName} avatar`;
        img.style.width = avatarSizeFor(pos.rank);
        img.style.height = avatarSizeFor(pos.rank);
        img.onerror = () => { img.src = player?.avatarPath || ""; };

        // stats
        const winRate = t.games ? (t.wins / t.games) : 0;
        const stats = document.createElement("div");
        stats.className = "pStats";
        stats.innerHTML = `
          <div class="k">rating ${t.rating.toFixed(2)}</div>
          <div class="k">avg pts ${t.avgPoints.toFixed(2)}</div>
          <div class="k">win ${pct(winRate)}</div>
        `;

        slot.appendChild(trophies);
        slot.appendChild(img);
        slot.appendChild(stats);

        // recent wins box (under avatar)
        const recentBox = document.createElement("div");
        recentBox.className = "recentBox";
        // place under the avatar (half avatar + padding)
        recentBox.style.top = `calc(50% + (${avatarSizeFor(pos.rank)} / 2) + 14px)`;

        const inner = document.createElement("div");
        inner.className = "recentInner";
        // ensure it fits 5 no matter rank
        inner.style.width = `clamp(240px, ${Math.max(18, pos.rank===1?26:22)}vmin, 320px)`;

        const wins = (recentWins.get(t.playerId) || []).slice(0,5);
        for(let i=0;i<5;i++){
          const w = wins[i];
          const li = document.createElement("img");
          li.style.width = recentIconSizeFor(pos.rank);
          li.style.height = recentIconSizeFor(pos.rank);
          if(w){
            li.src = w.path;
            li.alt = w.leaderName;
            li.onerror = () => { li.style.opacity = "0.0"; };
          }else{
            // empty slot keeps grid shape
            li.src = "";
            li.alt = "";
            li.style.opacity = "0";
          }
          inner.appendChild(li);
        }
        recentBox.appendChild(inner);

        // we attach recentBox to panel (absolute within slot via position absolute)
        slot.style.position = "absolute";
        slot.appendChild(recentBox);

        panel.appendChild(slot);
      }

      return panel;
    }

    function renderTimeline(matchesNewestFirst, playersMap){
      const panel = document.createElement("section");
      panel.className = "timelinePanel";

      const bgA = document.createElement("div");
      bgA.className = "bgParchment";
      bgA.dataset.parallax = "0.10";

      const bgB = document.createElement("div");
      bgB.className = "bgLines";
      bgB.dataset.parallax = "0.16";

      panel.appendChild(bgA);
      panel.appendChild(bgB);
      panel.appendChild(Object.assign(document.createElement("div"), { className: "timelineLine" }));

      const content = document.createElement("div");
      content.className = "timelineContent";
      panel.appendChild(content);

      const row = document.createElement("div");
      row.className = "nodesRow";
      content.appendChild(row);

      // Match #1 should be newest, so we number by index in matchesNewestFirst
      matchesNewestFirst.forEach((match, idx) => {
        const matchNo = idx + 1;

        const node = document.createElement("div");
        node.className = "matchNode";

        // TABLE
        const tableWrap = document.createElement("div");
        tableWrap.className = "matchTableWrap";

        const ordered = computePlacements(match);
        const winner = ordered.find(x => x.place === 1);
        const winnerPlayer = winner ? playersMap.get(winner.playerId) : null;
        const winnerName = winnerPlayer ? winnerPlayer.displayName : "Winner";
        const vt = safeText(match.victoryType || "");

        // visible container that clips ONLY table body area
        const top = document.createElement("div");
        top.className = "tableTop";

        // overhang pills (must not be clipped)
        const pillL = document.createElement("div");
        pillL.className = "pill left";
        pillL.textContent = `Match #${matchNo}`;

        const pillR = document.createElement("div");
        pillR.className = "pill right";
        pillR.textContent = safeText(match.dateUK);

        tableWrap.appendChild(pillL);
        tableWrap.appendChild(pillR);

        const title = document.createElement("div");
        title.className = "matchTitle";
        title.textContent = `${winnerName.toUpperCase()}'S ${vt.toUpperCase()} VICTORY`;

        top.appendChild(title);

        const table = document.createElement("table");
        table.innerHTML = `
          <thead>
            <tr>
              <th class="thPoints">Points</th>
              <th class="thPlayer">Player</th>
              <th class="thScore">Score</th>
              <th class="thLeader">Leader</th>
              <th class="thCiv">Civ</th>
            </tr>
          </thead>
          <tbody></tbody>
        `;
        const tbody = $("tbody", table);

        for(const r of ordered){
          const p = playersMap.get(r.playerId);
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td><strong>${r.points}</strong> pts</td>
            <td><strong>${p ? p.displayName : r.playerId}</strong></td>
            <td><strong>${r.score ?? 0}</strong></td>
            <td>${safeText(r.leaderName || "")}</td>
            <td>${safeText(r.civName || "")}</td>
          `;
          tbody.appendChild(tr);
        }

        top.appendChild(table);
        tableWrap.appendChild(top);
        node.appendChild(tableWrap);

        // PODIUM under table (perfect alignment columns)
        const podium = document.createElement("div");
        podium.className = "nodePodium";

        const p1 = ordered.find(x => x.place === 1);
        const p2 = ordered.find(x => x.place === 2);
        const p3 = ordered.find(x => x.place === 3);

        podium.appendChild(placeRow("üèÜ", p1, "gold", "m1"));
        podium.appendChild(placeRow("ü•à", p2, "silver", "m2"));
        podium.appendChild(placeRow("ü•â", p3, "bronze", "m3"));

        node.appendChild(podium);

        row.appendChild(node);
      });

      return panel;

      function placeRow(iconChar, entry, medal, sizeClass){
        const wrap = document.createElement("div");
        wrap.className = `placeRow ${sizeClass}`;

        const ico = document.createElement("div");
        ico.className = "placeIco";
        ico.textContent = iconChar;
        wrap.appendChild(ico);

        if(entry){
          const p = playersMap.get(entry.playerId);

          const pImg = document.createElement("img");
          pImg.className = `mPlayer ${sizeClass}`;
          pImg.src = avatarVariant(p, medal);
          pImg.alt = `${p?.displayName || entry.playerId} avatar`;
          pImg.onerror = () => { pImg.src = p?.avatarPath || ""; };
          wrap.appendChild(pImg);

          const cImg = document.createElement("img");
          cImg.className = `mCiv ${sizeClass}`;
          cImg.src = leaderAvatarPath(entry.leaderName || "");
          cImg.alt = safeText(entry.leaderName || "");
          cImg.onerror = () => { cImg.style.opacity = "0.0"; }; // hide if missing
          wrap.appendChild(cImg);
        } else {
          // keep row spacing consistent even if data missing
          const ph1 = document.createElement("div");
          ph1.style.width = "1px"; ph1.style.height = "1px"; ph1.style.opacity = "0";
          const ph2 = ph1.cloneNode();
          wrap.appendChild(ph1);
          wrap.appendChild(ph2);
        }

        return wrap;
      }
    }

    // --- Smooth inertial horizontal scroll (fixes ‚Äúfast wheel = slower travel‚Äù) ---
    function setupInertialWheel(scroller){
      let target = scroller.scrollLeft;
      let raf = null;

      function step(){
        raf = null;
        const cur = scroller.scrollLeft;
        const diff = target - cur;
        scroller.scrollLeft = cur + diff * 0.18;
        if(Math.abs(diff) > 0.5){
          raf = requestAnimationFrame(step);
        }
      }

      function normDelta(e){
        // deltaMode: 0=pixels, 1=lines, 2=pages
        let d = (Math.abs(e.deltaY) > Math.abs(e.deltaX)) ? e.deltaY : e.deltaX;

        if(e.deltaMode === 1) d *= 28;
        if(e.deltaMode === 2) d *= window.innerHeight;

        // Razer/high-res wheels can emit small deltas at high frequency:
        // make it feel consistent by applying a stronger multiplier, but clamp
        const mult = 1.35;
        d *= mult;

        // clamp extreme spikes but allow fast travel
        const cap = 2400;
        d = Math.max(-cap, Math.min(cap, d));
        return d;
      }

      scroller.addEventListener("wheel", (e) => {
        if(e.shiftKey) return;
        e.preventDefault();

        const d = normDelta(e);

        // update target relative to current target to preserve velocity
        target += d;

        const max = scroller.scrollWidth - scroller.clientWidth;
        if(target < 0) target = 0;
        if(target > max) target = max;

        if(!raf) raf = requestAnimationFrame(step);
      }, { passive:false });
    }

    function setupParallax(scroller){
      function update(){
        const x = scroller.scrollLeft;
        const layers = $$("[data-parallax]");
        layers.forEach(layer => {
          const k = parseFloat(layer.dataset.parallax || "0");
          layer.style.transform = `translate3d(${-x * k}px, 0, 0)`;
        });
      }
      scroller.addEventListener("scroll", update);
      update();
    }

    async function main(){
      const res = await fetch("data.json", { cache: "no-store" });
      if(!res.ok) throw new Error(`Failed to load data.json (${res.status})`);
      const data = await res.json();

      const players = data.players || [];
      let matches = (data.matches || []).slice();

      // newest -> oldest (left to right)
      matches.sort((a,b) => parseUKDateKey(b.dateUK).localeCompare(parseUKDateKey(a.dateUK)));

      const playersMap = byId(players);
      const totals = buildTotals(players, matches);

      const row = document.getElementById("row");
      row.innerHTML = "";
      row.appendChild(renderPodium(totals, matches, playersMap));

      const timeline = renderTimeline(matches, playersMap);
      row.appendChild(timeline);

      // timeline width for many games
      const css = getComputedStyle(document.documentElement);
      const nodeW = parseFloat(css.getPropertyValue("--nodeW")) || 650;
      const gap = parseFloat(css.getPropertyValue("--nodeGap")) || 120;
      const pad = parseFloat(css.getPropertyValue("--timelinePad")) || 170;
      const nodesCount = matches.length;

      const nodesTotal = nodesCount * nodeW + Math.max(0, nodesCount - 1) * gap;
      const desired = pad + nodesTotal + pad;
      timeline.style.width = Math.max(window.innerWidth, desired) + "px";

      const scroller = document.getElementById("scroller");
      scroller.focus();

      setupInertialWheel(scroller);
      setupParallax(scroller);

      window.addEventListener("resize", () => {
        const nodeW2 = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--nodeW")) || nodeW;
        const gap2  = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--nodeGap")) || gap;
        const pad2  = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--timelinePad")) || pad;
        const nodesTotal2 = nodesCount * nodeW2 + Math.max(0, nodesCount - 1) * gap2;
        const desired2 = pad2 + nodesTotal2 + pad2;
        timeline.style.width = Math.max(window.innerWidth, desired2) + "px";
      });
    }

    main().catch(err => {
      console.error(err);
      document.body.innerHTML = `
        <div style="padding:24px; font-family:system-ui; color:#fff;">
          <h1 style="margin:0 0 10px 0; color:${'#d5ac56'};">ZIKA CIV LEAGUE</h1>
          <p style="opacity:.9; line-height:1.5;">Could not load <code>data.json</code>. Make sure you're using <code>python -m http.server</code>.</p>
          <pre style="white-space:pre-wrap; background:rgba(255,255,255,0.08); padding:12px; border-radius:12px;">${String(err)}</pre>
        </div>
      `;
    });
  </script>
</body>
</html>
